# 14장 회고

목록의 모든 피처를 구현했다. 다음은 알기 쉽게 정리한 구현된 피처 목록이다.

- [x] 5달러 \* 2 = 10달러
- [x] 10유로 \* 2 = 20유로
- [x] 4002원 / 4 = 1000.
- [x] 5달러 + 10달러 = 15달러
- [x] 프로덕션 코드와 테스트 코드 분리
- [x] 중복된 테스트 제거
- [x] 5달러 + 10유로 = 17달러
- [x] 1달러 + 1100원 = 2200원
- [x] 연관된 통화에 기반한 환율 결정 (환전 전 -> 환전 후)
- [x] 환율이 명시되지 않은 경우 오류 처리 개선
- [x] 환율 구현 개선
- [x] 환율 수정 허용

그러나 구현했다고 해서 끝이 아니다. 소프트웨어는 항상 '변경'될 수 있다. 소프트웨어를 둘러싼 여러 요인들로 인해 변경이 필요할 수 있다. 이러한 요인들은 다음과 같다.

- 요구사항 변경
- 언어나 프레임워크의 업데이트
- 새로운 기술의 도입
- 사용자의 피드백
- 기타 등등

그렇다고 해서 현시점에서 미래의 변경사항까지 고려하고 코드를 작성하는 것은 불가능하다. 그렇다면 잠재적인 변경사항에 대비하기 위해 당장 할 수 있는 것은 무엇일까? 그것은 '회고'를 통해 현 시점의 코드를 돌아보고 개선점을 찾아내는 것이다.

회고 사항은 다음 관점에 따라 맞춰본다.

- 프로필: 코드의 형태와 구조에 대한 회고
- 목적: 코드의 목적과 기능에 대한 회고
- 프로세스: 현재 위치에 어떻게 도달했는지, 다른 어떤 방법이 가능했는지, 특정 경로를 선택한 이유는 무엇인지에 대한 회고

## 프로필 (Profile)

프로필은 복잡도, 단순성 및 결합도의 관점에서 코드를 살펴본다. 이 책의 서문에서 단순성을 핵심 용어로 식별했으므로, 단순성을 중심으로 코드를 살펴보자.

### 순환 복잡도

코드에 분기와 반복이 포함된 정도를 측정하는 척도로, 분기와 반복을 줄여 코드를 단순하게 만들어야 한다.

한 코드 블록의 순환 복잡도는 코드의 반복문과 분기문의 개수에 1을 더한 값이다. 분기나 반복이 없는 코드 블록은 1의 순환 복잡도를 가진다.

이 개념을 제안한 맥케이브에 의하면 순환 복잡도의 상한선은 10이다.

### 결합도

결합도는 코드의 의존성을 측정하는 척도로, 두 모듈 간의 상호 의존성이 얼마나 강한지를 나타낸다.

결합도의 두 가지 유형은 다음과 같다.

- 입력 결합도: 주어진 모듈, 컴포넌트에 의존하는 다른 모듈, 컴포넌트의 수
- 출력 결합도: 주어진 모듈, 컴포넌트가 의존하는 다른 모듈, 컴포넌트의 수

코드 안정성의 측정 척도는 입력과 출력 결합도 간의 균형이다. 코드의 불안전성은 다음 수식으로 정의된다.

```
불안전성 = (출력 결합도) / (출려 결합도 + 입력 결합도)
```

불안정성은 0과 1 사이의 값을 가지며, 1에 가까울수록 불안정하다. 1은 해당 컴포넌트가 다른 컴포넌트에는 의존하나, 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않는 상태를 의미한다.

### 단순성

코드 라인 수로 코드의 복잡성을 측정하려는 시도는 다소 무리가 있다. 언어에 따라, 하나의 언어에서도 동일한 동작을 수행하는 코드가 다양한 형태로 작성될 수 있기 때문이다.

(이 부분은 내용이 조금 이상한데?)

## 목적

모든 코드는 어떤 필요를 충족시키기 위해 작성된다. 코드의 목적을 명확히 이해하고, 목적을 달성하기 위해 코드가 어떻게 작성되었는지를 이해하는 것은 코드를 개선하는 데 중요한 요소이다.

코드 조각이 목적을 충족시키는 정도는 두 가지 관점에서 살펴볼 수 있다.

1. 모든 게 의도한 대로 작동하는가? (완전성)
2. 해야 할 동작만 수행하고 있는가? (응집도)

### 완전성

코드가 해야 할 일을 모두 수행하는가? 피처 목록의 체크리스트가 모두 완료되었는지를 완전성의 하나의 지표로 볼 수 있다.

그러나 테스트가 과연 얼마나 완전한지는 또 다른 문제이다. 다음 경우를 생각해보자.

- 오버플로: Money 엔티티를 더하거나 곱할 때 오버플로가 발생할 수 있다. 오버프로는 특정 데이터 타입의 최대값을 초과하는 경우 발생한다.
- 0으로 나누기: 0으로 나누는 경우, 런타임 에러가 발생한다. 이를 테스트에서 직접 다루지 않았다.

이런 시나리오 중 어떤 것도 현재 고려되지 않았다. 이는 코드가 완전하다고 말할 수 없는 증거이다. 그러나 이러한 것들도 결국 테스트 주도 개발을 통해 해결할 수 있다.

## 프로세스

프로필과 목적은 최종 결과물에 대한 회고이다. 그러나 프로세스는 현재 위치에 도달하기까지의 과정을 살펴보는 것이다.

체크리스트에 있는 것과 다른 순서로 피처를 개발하기 시작했다면 어땠을까? 피처를 정리하는 방식에서 가장 우선적으로 고려된 사항은 '가장 간단한 것 먼저'라는 원칙이었다. 하지만 이 원칙을 따르지 않고 다른 통화를 더하는 기능을 먼저 구현했다면 환율을 상당히 일찍 도입했을 것이다.

이러한 선택은 어떤 결과를 가져왔을까? 이러한 선택이 코드의 구조나 품질에 어떤 영향을 미쳤을까? 다양한 선택지 중에서 왜 이 선택을 했는지에 대한 이유를 살펴보고 다른 선택지가 어떤 결과를 가져왔을지 생각해보자.

## 모두 합치기

코드 분석에 사용할 수 있는 프로필, 목적 및 프로세스의 세 가지 관점을 살펴보았다. 작성했던 코드를 세 가지 관점을 투영하여 어떤 모습인지 살펴보자.

### 프로필

Go의 코드 순환 복잡도는 gocyclo를 사용하여 측정할 수 있다. gocyclo를 설치하려면 다음 명령을 실행하면 된다.

```bash
$ go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
```

gocyclo를 사용하려면 다음 명령을 실행하면 된다.

```bash
$ gocyclo .
```

결과는 다음과 같다.

```bash
$ gocyclo .
4 stocks (Portfolio).Evaluate go/stocks/portfolio.go:14:1
3 stocks (Bank).Convert go/stocks/bank.go:14:1
3 main assertNil go/money_test.go:129:1
2 main assertEqual go/money_test.go:135:1
2 main TestConversionWithMissingExchangeRate go/money_test.go:117:1
1 stocks (Portfolio).Add go/stocks/portfolio.go:10:1
1 stocks (Money).Divide go/stocks/money.go:22:1
1 stocks (Money).Times go/stocks/money.go:15:1
1 stocks NewMoney go/stocks/money.go:8:1
1 stocks NewBank go/stocks/bank.go:28:1
1 stocks (Bank).AddExchangeRate go/stocks/bank.go:9:1
1 main TestConversionWithDifferentRatesBetweenTwoCurrencies go/money_test.go:102:1
1 main TestAdditionWithMultipleMissingExchangeRates go/money_test.go:82:1
1 main TestAdditionDollarsAndWon go/money_test.go:64:1
1 main TestAdditionDollarsAndEuros go/money_test.go:47:1
1 main TestAddition go/money_test.go:31:1
1 main TestDivision go/money_test.go:24:1
1 main TestMultiplication go/money_test.go:17:1
1 main initExchangeRates go/money_test.go:11:1
```

가장 높은 순환 복잡도는 4이다. 이는 매우 낮은 수치이다. 이는 코드가 단순하다는 것을 의미한다.

단순성에 있어 Go는 수상한 코드를 검사하는 도구를 제공한다. go vet은 코드를 검사하여 잠재적인 문제를 찾아낸다. go vet을 사용하려면 다음 명령을 실행하면 된다.

```bash
$ go vet ./...
```

vet 명령어는 불필요한 코드를 찾을 뿐만 아니라, Go 구문의 일반적인 오류에 대해서도 경고를 제공한다.

### 목적

우리의 Go 코드는 잘 정의된 책임을 바탕으로 한 세 개의 엔티티, Money, Bank, Portfolio로 구성되어 있으므로 응집도가 높다. 다만 Money에 더하는 기능이 존재하지 않아서 amount를 더하는 작업을 Portfolio의 Evaluate에서 수행하는 것이 문제가 될 수 있다.

### 프로세스

1. 테스트 코드와 같은 파일에 프로덕션 코드를 작성했다.
2. stocks 패키지를 만들어서 테스트 코드와 프로덕션 코드를 분리했다. stocks 패키지에는 Money와 Portfolio가 포함되어 있다.
3. Portfolio에서 환율을 관리하고 환전을 수행하는 책임을 Bank로 분리하였다.

## 테스트 주도 개발은 죽었다?

테스트 주도 개발은 코드를 설계하고 구조화하는 기술로써, 그 목적은 코드에 단순성을 부여하고 변경에 대한 자신감을 상승시키는데 있다. 테스트 주도 개발 과정에서 작성한 단위 테스트는 이를 위한 수단이며, 그 자체가 목적이 아니다. 이는 최종 사용자의 요구사항을 충족시킬 때 분명해진다.

건물에 가설하는 비계(scaffolding)처럼 테스트 코드는 프로덕션 코드를 지탱하기 위한 것이다. 건물이 완성되면 비계는 제거된다. 마찬가지로 테스트 코드는 프로덕션 코드가 완성되면 빌드 프로세스에서 제외된다. 그러나 완전히 제거되지는 않는다. 코드는 언제든지 변경될 수 있으므로, 단위 테스트를 계속 유지하고 CI/CD 파이프라인을 통해 주기적으로 실행하여 개선해 나가야 한다.

하지만 놓쳐서는 안 되는 점으로, 테스트 주도 개발의 목적이 프로덕션 코드의 정교함을 높이는데 있다는 것을 기억해야 한다. 만약 테스트 주도 개발 없이도 완벽한 코드를 작성할 수 있다면, 그것이 더 좋은 방법이라면 그것을 선택해야 한다. 다만 아직까지는 테스트 주도 개발이 코드의 완성도를 높이는 가장 좋은 방법이라는 것은 변함없다. 또한 아직은 보편적인 테스트 이론이나 방법론이 부족한 상태이다. 그러한 점에서 테스트 주도 개발은 여전히 유효한 방법론이다.

## 결론

테스트 주도 개발은 코드의 단순성을 유지하고 변경에 대한 자신감을 높이는데 탁월한 방법이다. 그러나 테스트 주도 개발이라는 방법론이 죽었다고 말하는 것은 납득하기 어려운 주장이다. 테스트 주도 개발은 여전히 유효한 방법론이며, 이를 통해 경험적, 이론적 지식을 쌓아나가는 것이 중요하다.
