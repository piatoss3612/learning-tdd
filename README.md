# 4장 관심사의 분리

지금까지 단일 파일에 작성한 코드는 라인 수가 늘어나고 있다. 이는 코드를 읽고 이해하기 어렵게 만든다. 리팩토링을 통해 코드를 더 작고 읽기 쉽게 만드는 데 시간을 할애해야 한다.

## 테스트 코드와 프로덕션 코드

지금까지 두 종류의 코드를 작성했다.

1. 프로덕션 코드: 돈 문제를 해결하기 위한 코드. Money와 Portfolio 엔티티를 정의하고 관련 동작을 구현했다.
2. 테스트 코드: 프로덕션 코드를 검증하는 코드. 모든 테스트 및 테스트 지원에 필요한 코드를 포함한다.

동일한 언어로 작성되었다고는 하나 두 코드 사이에는 분명한 차이가 있다.

### 단방향 의존성

테스트 코드는 프로덕션 코드에 의존하는 반면 프로덕션 코드는 테스트 코드에 의존하지 않는다. 이러한 관계를 단방향 의존성이라고 한다. 프로덕션 코드는 테스트 코드 없이도 독립적으로 존재할 수 있지만 테스트 코드는 프로덕션 코드 없이는 존재할 수 없다.

만약에라도 프로덕션 코드가 테스트 코드에 대한 암시적 의존성을 가지지 않도록 다음을 참고하자.

1. 코드를 작성할 때: 프로덕션 코드에서 어떤 테스트 코드라도 실수로 사용하지 않도록 주의해야 한다.
2. 코드를 읽을 때: 프로덕션 코드는 어떤 테스트 코드도 호출할 수 없도록 신경 써야 한다.

### 의존성 주입

의존성 주입은 객체의 생성과 사용을 분리하는 방법이다. 객체를 생성하는 책임을 외부로 옮기고 생성된 객체를 사용하는 책임을 객체 자신에게 맡긴다. 이를 통해 코드의 응집력을 높이고 결합도를 낮출 수 있다.

프로덕션 코드를 테스트하는 경우 의존성 주입을 사용하면 테스트 코드에서 프로덕션 코드에 임의의 객체를 주입할 수 있다. 이를 통해 테스트 코드에서 프로덕션 코드의 동작을 제어할 수 있다.

### 패키징 및 배포

배포를 위해 애플리케이션을 패키징할 때 테스트 코드는 일반적으로 프로덕션 코드와 분리된다. 이는 테스트 코드와 프로덕션 코드가 독립적으로 배포될 수 있음을 의미한다.

## 모듈화

프로덕션 코드와 테스트 코드를 분리하는 방법은 모듈화를 통해 이루어진다. 모듈화란 코드를 논리적인 단위로 분리하는 것이다. 이는 테스트 코드에서 프로덕션 코드를 including, importing, requiring하는 문제를 해결하고 단방향 의존성을 유지하는 데 도움이 된다.

### 모듈화 방법

1. 파일 분리: 독립적으로 읽고 쓸 수 있도록 프로덕션 코드와 테스트 코드를 서로 다른 파일로 분리한다.
2. 네임스페이스: 어떤 엔티티들이 같이 묶이는지 명시적으로 식별할 수 있도록 네임스페이스를 사용한다.
3. 의존성 명시: 명시적인 코드 지시문(import, require 등)이 하나의 모듈이 다른 모듈에 의존한다는 것을 나타내도록 한다.
4. 자기 설명적인 코드: 코드를 읽는 사람이 코드의 의도를 쉽게 이해할 수 있도록 적절한 이름, 순서 병경, 주석 등을 사용한다.

## 의존성 제거

다음은 테스트에서 의존성을 제거하는 것이다.

지금까지 두 개의 곱셈 테스트(달러, 유로)를 만들었다. 두 곱셈 테스트를 계속 유지해야 할까? 결정을 내리기 위한 체크리스트는 다음과 같다.

1. 테스트를 지워도 코드 커버리지에 영향을 미치지 않는가? -> 네, 두 테스트는 동일한 코드 라인을 커버한다.
2. 테스트 중 하나가 중요한 특이 상황을 검증하는가? -> 아니오, 두 테스트는 완전히 동일하다.
3. 서로 다른 테스트가 살아있는 문서로써 고유한 가치를 제공하는가? -> 아니오, 두 테스트는 최소한의 문서 역할만 한다.

## 중간 점검

다음으로 넘어가기 전에 피처 목록을 갱신하여 무엇을 해야 하는지 정리하자.

- [x] 5달러 \* 2 = 10달러
- [x] 10유로 \* 2 = 20유로
- [x] 4002원 / 4 = 1000.
- [x] 5달러 + 10달러 = 15달러
- [ ] 프로덕션 코드와 테스트 코드 분리
- [ ] 중복된 테스트 제거
- [ ] 5달러 + 10유로 = 17달러
- [ ] 1달러 + 1100원 = 2200원
